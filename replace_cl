# Replacing xp_cmdshell with CLR in SQL Server

Moving from xp_cmdshell to CLR (Common Language Runtime) assemblies is a good security practice as it provides more controlled access to external operations. Here are examples of how to replace xp_cmdshell functionality with CLR alternatives.

## Simple Example: File System Operations

### Original xp_cmdshell code:
```sql
-- Create directory
EXEC xp_cmdshell 'mkdir C:\temp\newfolder';

-- List files
EXEC xp_cmdshell 'dir C:\temp\';
```

### CLR Replacement:

1. First, create a C# CLR assembly:

```csharp
using System;
using System.IO;
using System.Data.SqlTypes;
using Microsoft.SqlServer.Server;

public class FileSystemUtils
{
    [SqlProcedure]
    public static void CreateDirectory(SqlString path)
    {
        try
        {
            Directory.CreateDirectory(path.Value);
            SqlContext.Pipe.Send($"Directory created: {path}");
        }
        catch (Exception ex)
        {
            SqlContext.Pipe.Send($"Error creating directory: {ex.Message}");
        }
    }

    [SqlProcedure]
    public static void ListFiles(SqlString path)
    {
        try
        {
            foreach (string file in Directory.GetFiles(path.Value))
            {
                SqlContext.Pipe.Send(file);
            }
        }
        catch (Exception ex)
        {
            SqlContext.Pipe.Send($"Error listing files: {ex.Message}");
        }
    }
}
```

2. Deploy and use in SQL Server:
```sql
-- Register the assembly
CREATE ASSEMBLY FileSystemUtils FROM 'C:\path\to\FileSystemUtils.dll' 
WITH PERMISSION_SET = EXTERNAL_ACCESS;

-- Create the procedures
CREATE PROCEDURE clr_CreateDirectory(@path nvarchar(4000))
AS EXTERNAL NAME FileSystemUtils.FileSystemUtils.CreateDirectory;

CREATE PROCEDURE clr_ListFiles(@path nvarchar(4000))
AS EXTERNAL NAME FileSystemUtils.FileSystemUtils.ListFiles;

-- Usage
EXEC clr_CreateDirectory 'C:\temp\newfolder';
EXEC clr_ListFiles 'C:\temp\';
```

## Advanced Example: Execute Process with Output

### Original xp_cmdshell code:
```sql
-- Execute a command and get output
DECLARE @result int
EXEC @result = xp_cmdshell 'ping google.com', NO_OUTPUT;
SELECT @result AS ReturnCode;
```

### CLR Replacement:

1. C# CLR assembly code:

```csharp
using System;
using System.Diagnostics;
using System.Data.SqlTypes;
using Microsoft.SqlServer.Server;

public class ProcessUtils
{
    [SqlProcedure]
    public static SqlInt32 ExecuteProcess(SqlString command, SqlString arguments, out SqlString output)
    {
        output = SqlString.Null;
        try
        {
            ProcessStartInfo psi = new ProcessStartInfo
            {
                FileName = command.Value,
                Arguments = arguments.IsNull ? "" : arguments.Value,
                RedirectStandardOutput = true,
                RedirectStandardError = true,
                UseShellExecute = false,
                CreateNoWindow = true
            };

            using (Process process = Process.Start(psi))
            {
                string result = process.StandardOutput.ReadToEnd();
                string errors = process.StandardError.ReadToEnd();
                process.WaitForExit(30000); // 30 second timeout

                output = result + errors;
                return process.ExitCode;
            }
        }
        catch (Exception ex)
        {
            output = ex.Message;
            return -1;
        }
    }
}
```

2. Deploy and use in SQL Server:
```sql
-- Register the assembly
CREATE ASSEMBLY ProcessUtils FROM 'C:\path\to\ProcessUtils.dll' 
WITH PERMISSION_SET = EXTERNAL_ACCESS;

-- Create the procedure
CREATE PROCEDURE clr_ExecuteProcess
    @command nvarchar(4000),
    @arguments nvarchar(4000) = NULL,
    @output nvarchar(MAX) OUTPUT
AS EXTERNAL NAME ProcessUtils.ProcessUtils.ExecuteProcess;

-- Usage
DECLARE @out nvarchar(MAX), @rc int;
EXEC @rc = clr_ExecuteProcess 'ping', 'google.com', @out OUTPUT;
SELECT @rc AS ReturnCode, @out AS Output;
```

## Security Considerations

1. Always sign your assemblies and use appropriate permission sets:
```sql
-- Create asymmetric key from assembly file
CREATE ASYMMETRIC KEY CLRUtilsKey FROM EXECUTABLE FILE = 'C:\path\to\ProcessUtils.dll';

-- Create login from the key
CREATE LOGIN CLRUtilsLogin FROM ASYMMETRIC KEY CLRUtilsKey;

-- Grant external access
GRANT EXTERNAL ACCESS ASSEMBLY TO CLRUtilsLogin;
```

2. Use EXTERNAL_ACCESS permission set unless you specifically need UNSAFE.

3. Validate all input parameters in your CLR code to prevent injection attacks.

## Additional Examples

### File Read/Write Operations

Original xp_cmdshell approach might use `type` or `echo` commands. With CLR:

```csharp
[SqlProcedure]
public static SqlString ReadFile(SqlString path)
{
    try
    {
        return File.ReadAllText(path.Value);
    }
    catch (Exception ex)
    {
        return $"Error reading file: {ex.Message}";
    }
}

[SqlProcedure]
public static void WriteFile(SqlString path, SqlString content)
{
    try
    {
        File.WriteAllText(path.Value, content.Value);
        SqlContext.Pipe.Send("File written successfully");
    }
    catch (Exception ex)
    {
        SqlContext.Pipe.Send($"Error writing file: {ex.Message}");
    }
}
```

These examples demonstrate how to replace common xp_cmdshell operations with more secure CLR alternatives. The CLR approach provides better type safety, error handling, and security control.
