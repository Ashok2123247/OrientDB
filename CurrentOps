Here are two formal options for your requirement. Both scripts query **SQL Server DMV data** to capture **Page Life Expectancy (PLE)** and **RESOURCE\_SEMAPHORE waits** in the last 1 minute to assess memory pressure.

---

## **Option 1: DMV-based Snapshot with Delta Calculation**

This script collects current values, waits 1 minute, recollects, and then calculates averages.

```sql
-- Script: Memory Pressure Check using DMV snapshots
SET NOCOUNT ON;

-- First snapshot
IF OBJECT_ID('tempdb..#memcheck') IS NOT NULL DROP TABLE #memcheck;
CREATE TABLE #memcheck
(
    snapshot_time DATETIME,
    ple_value BIGINT,
    wait_time_ms BIGINT,
    waiting_tasks BIGINT
);

INSERT INTO #memcheck
SELECT 
    GETDATE() AS snapshot_time,
    cntr_value AS ple_value,
    ws.wait_time_ms,
    ws.waiting_tasks_count
FROM sys.dm_os_performance_counters pc
LEFT JOIN sys.dm_os_wait_stats ws 
    ON ws.wait_type = 'RESOURCE_SEMAPHORE'
WHERE pc.counter_name = 'Page life expectancy'
  AND pc.object_name LIKE '%Buffer Manager%';

-- Wait for 1 minute
WAITFOR DELAY '00:01:00';

-- Second snapshot
INSERT INTO #memcheck
SELECT 
    GETDATE() AS snapshot_time,
    cntr_value AS ple_value,
    ws.wait_time_ms,
    ws.waiting_tasks_count
FROM sys.dm_os_performance_counters pc
LEFT JOIN sys.dm_os_wait_stats ws 
    ON ws.wait_type = 'RESOURCE_SEMAPHORE'
WHERE pc.counter_name = 'Page life expectancy'
  AND pc.object_name LIKE '%Buffer Manager%';

-- Calculate deltas in last 1 min
;WITH cte AS
(
    SELECT 
        MIN(snapshot_time) AS start_time,
        MAX(snapshot_time) AS end_time,
        MAX(ple_value) - MIN(ple_value) AS ple_change,
        MAX(wait_time_ms) - MIN(wait_time_ms) AS wait_ms_change,
        MAX(waiting_tasks) - MIN(waiting_tasks) AS waiting_tasks_change
    FROM #memcheck
)
SELECT 
    start_time, 
    end_time,
    ple_change AS PLE_Delta,
    wait_ms_change AS WaitTimeMs_Delta,
    waiting_tasks_change AS WaitingTasks_Delta,
    CASE 
        WHEN ple_change < 0 OR waiting_tasks_change > 0 THEN 'Possible Memory Pressure'
        ELSE 'No Significant Memory Pressure'
    END AS MemoryPressureStatus
FROM cte;
```

âœ… **Best for automation jobs (SQL Agent) â€“ compares delta in PLE & semaphore waits.**

---

## **Option 2: Real-Time Aggregated Query (1 Minute Window Using sys.dm\_exec\_requests + sys.dm\_os\_waiting\_tasks)**

Instead of waiting, you can calculate average semaphore waits within the last minute by joining request data.

```sql
-- Script: Real-time Memory Pressure Indicators
SET NOCOUNT ON;

-- Current PLE
SELECT 
    GETDATE() AS CheckTime,
    cntr_value AS PLE_Value
FROM sys.dm_os_performance_counters
WHERE counter_name = 'Page life expectancy'
  AND object_name LIKE '%Buffer Manager%';

-- Average Resource Semaphore waits in last 1 min
;WITH waits AS
(
    SELECT 
        wait_type,
        wait_time_ms,
        signal_wait_time_ms,
        waiting_tasks_count,
        (wait_time_ms / NULLIF(waiting_tasks_count,0)) AS AvgWaitPerTask
    FROM sys.dm_os_wait_stats
    WHERE wait_type = 'RESOURCE_SEMAPHORE'
)
SELECT 
    GETDATE() AS CheckTime,
    wait_type,
    wait_time_ms,
    waiting_tasks_count,
    AvgWaitPerTask,
    CASE 
        WHEN AvgWaitPerTask > 1000 THEN 'Potential Memory Pressure'
        ELSE 'Normal'
    END AS MemoryPressureStatus
FROM waits;
```

âœ… **Best for quick monitoring or integrating into a monitoring system.**

---

ðŸ‘‰ Recommendation:

* Use **Option 1** if you want a **trend/delta analysis** every 1 minute.
* Use **Option 2** if you need **real-time snapshots** integrated into monitoring (like Grafana, custom dashboards, or alerts).

Would you like me to **combine both scripts into one procedure** that logs results to a table for continuous tracking of memory pressure trends?
