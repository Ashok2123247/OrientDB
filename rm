DECLARE @dbList NVARCHAR(MAX) = 'UserDB1,UserDB2,UserDB3'  -- Your comma-separated list
DECLARE @dbName NVARCHAR(255)
DECLARE @recoveryModelBefore NVARCHAR(20)
DECLARE @recoveryModelAfter NVARCHAR(20)
DECLARE @sql NVARCHAR(MAX)

-- Create temp table to hold cleaned DB names
IF OBJECT_ID('tempdb..#SelectedDbs') IS NOT NULL DROP TABLE #SelectedDbs
CREATE TABLE #SelectedDbs (DbName NVARCHAR(255))

-- Insert trimmed names from string split
INSERT INTO #SelectedDbs (DbName)
SELECT LTRIM(RTRIM(value))
FROM STRING_SPLIT(@dbList, ',')
WHERE LTRIM(RTRIM(value)) NOT IN ('master', 'model', 'msdb', 'tempdb')

-- Loop through each DB
DECLARE db_cursor CURSOR FOR
SELECT DbName FROM #SelectedDbs

OPEN db_cursor
FETCH NEXT FROM db_cursor INTO @dbName

WHILE @@FETCH_STATUS = 0
BEGIN
    -- Get current recovery model
    SELECT @recoveryModelBefore = recovery_model_desc
    FROM sys.databases
    WHERE name = @dbName

    PRINT 'Database: ' + @dbName
    PRINT '  BEFORE: Recovery Model = ' + ISNULL(@recoveryModelBefore, 'NOT FOUND')

    -- Change to SIMPLE if currently FULL
    IF @recoveryModelBefore = 'FULL'
    BEGIN
        SET @sql = 'ALTER DATABASE [' + @dbName + '] SET RECOVERY SIMPLE;'
        EXEC sp_executesql @sql
    END

    -- Get recovery model after change
    SELECT @recoveryModelAfter = recovery_model_desc
    FROM sys.databases
    WHERE name = @dbName

    PRINT '  AFTER : Recovery Model = ' + ISNULL(@recoveryModelAfter, 'NOT FOUND')
    PRINT '--------------------------------------------'

    FETCH NEXT FROM db_cursor INTO @dbName
END

CLOSE db_cursor
DEALLOCATE db_cursor
DROP TABLE #SelectedDbs
